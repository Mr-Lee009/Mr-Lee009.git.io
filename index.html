<!doctype html>
<html lang="vi">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Deep Connect â€” Quiz Flip</title>
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<div class="app">
			<header class="app-header">
				<h1>Deep Connect</h1>
				<div class="controls">
					<label class="sr-only" for="difficultyFilter">Má»©c Ä‘á»™</label>
					<select id="difficultyFilter" class="control">
						<option value="__ALL__">Táº¥t cáº£ má»©c Ä‘á»™</option>
					</select>

					<label class="sr-only" for="topicFilter">Chá»§ Ä‘á»</label>
					<select id="topicFilter" class="control">
						<option value="__ALL__">Táº¥t cáº£ chá»§ Ä‘á»</option>
					</select>

					<div class="spacer"></div>

					<button id="prevBtn" class="control">â—€ TrÆ°á»›c</button>
					<button id="flipBtn" class="control primary">Láº­t Ä‘á»ƒ tháº£o luáº­n</button>
					<button id="nextBtn" class="control">Sau â–¶</button>
					<button id="shuffleBtn" class="control">ğŸ”€ Ngáº«u nhiÃªn</button>
				</div>
				<div id="progress" class="progress">CÃ¢u 0/0</div>
			</header>

			<main class="stage">
				<div id="card" class="card" aria-label="Tháº» cÃ¢u há»i" role="button" tabindex="0">
					<div class="badge difficulty-badge" id="difficultyBadge">Má»©c Ä‘á»™</div>
					<div class="face front" id="cardQuestion">CÃ¢u há»i</div>
					<div class="face back" id="cardAnswer">ÄÃ¡p Ã¡n</div>
					<button id="answeredBtn" class="card-action" title="ÄÃ¡nh dáº¥u Ä‘Ã£ tráº£ lá»i vÃ  xÃ³a khá»i ngÃ¢n hÃ ng">âœ” ÄÃ£ tráº£ lá»i</button>
				</div>
			</main>

			<footer class="app-footer">
				<div class="hints">
					<span>PhÃ­m táº¯t: Space=Láº­t â€¢ â†/â†’=TrÆ°á»›c/Sau â€¢ S=Ngáº«u nhiÃªn</span>
				</div>
			</footer>
		</div>

		<!-- Data source -->
		<script src="data.js"></script>
		<!-- Inline logic for a simple static build -->
		<script>
			(function () {
				const data = (window.DeepConnectData || []).slice();
				// Auto-advance after flipping to the back
				const autoAdvanceDelayMs = 1800;
				let advanceTimer = null;

				// Audio
				let audioCtx = null;
				function ensureAudio() {
					if (!audioCtx) {
						audioCtx = new (window.AudioContext || window.webkitAudioContext)();
					}
					if (audioCtx.state === 'suspended') {
						audioCtx.resume();
					}
				}
				function playFlipOpen() {
					ensureAudio();
					const ctx = audioCtx;
					const osc = ctx.createOscillator();
					const gain = ctx.createGain();
					osc.type = 'triangle';
					osc.frequency.setValueAtTime(600, ctx.currentTime);
					gain.gain.setValueAtTime(0, ctx.currentTime);
					gain.gain.linearRampToValueAtTime(0.18, ctx.currentTime + 0.02);
					gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.22);
					osc.connect(gain).connect(ctx.destination);
					osc.start(ctx.currentTime);
					osc.stop(ctx.currentTime + 0.24);
				}

				function playFlipClose() {
					ensureAudio();
					const ctx = audioCtx;
					const osc = ctx.createOscillator();
					const gain = ctx.createGain();
					osc.type = 'sine';
					osc.frequency.setValueAtTime(240, ctx.currentTime);
					osc.frequency.exponentialRampToValueAtTime(140, ctx.currentTime + 0.15);
					gain.gain.setValueAtTime(0, ctx.currentTime);
					gain.gain.linearRampToValueAtTime(0.16, ctx.currentTime + 0.02);
					gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.18);
					osc.connect(gain).connect(ctx.destination);
					osc.start(ctx.currentTime);
					osc.stop(ctx.currentTime + 0.2);
				}

				// State
				let filtered = data.slice();
				let currentIndex = 0;
				// 0: chá»‰ sá»‘ thá»© tá»±, 1: cÃ¢u há»i, 2: Ä‘Ã¡p Ã¡n
				let revealStage = 0;

				// Elements
				const difficultyFilterEl = document.getElementById('difficultyFilter');
				const topicFilterEl = document.getElementById('topicFilter');
				const prevBtn = document.getElementById('prevBtn');
				const nextBtn = document.getElementById('nextBtn');
				const flipBtn = document.getElementById('flipBtn');
				const shuffleBtn = document.getElementById('shuffleBtn');
				const answeredBtn = document.getElementById('answeredBtn');
				const cardEl = document.getElementById('card');
				const qEl = document.getElementById('cardQuestion');
				const aEl = document.getElementById('cardAnswer');
				const progressEl = document.getElementById('progress');
				const badgeEl = document.getElementById('difficultyBadge');

				// Helpers
				function uniq(xs) {
					return Array.from(new Set(xs));
				}
				function fisherYatesShuffle(arr) {
					for (let i = arr.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[arr[i], arr[j]] = [arr[j], arr[i]];
					}
					return arr;
				}
				function clampIndex(i) {
					if (!filtered.length) return 0;
					while (i < 0) i += filtered.length;
					while (i >= filtered.length) i -= filtered.length;
					return i;
				}
				function setFlipped(flipped) {
					const want = !!flipped;
					const was = cardEl.classList.contains('flipped');
					if (was === want) return;
					cardEl.classList.toggle('flipped', want);
					if (want) playFlipOpen(); else playFlipClose();
				}

				function updateFaces() {
					if (!filtered.length) return;
					const item = filtered[currentIndex];
					// Máº·t trÆ°á»›c luÃ´n hiá»ƒn thá»‹ sá»‘ thá»© tá»±
					qEl.textContent = `CÃ¢u ${currentIndex + 1}`;
					// Máº·t sau hiá»ƒn thá»‹ theo giai Ä‘oáº¡n
					if (revealStage === 0) {
						aEl.textContent = '';
					} else if (revealStage === 1) {
						aEl.textContent = item.question;
					} else {
						const hasAnswer = typeof item.answer === 'string' && item.answer.trim().length > 0;
						aEl.textContent = hasAnswer ? item.answer : 'HÃ£y cÃ¹ng chia sáº» cáº£m nháº­n, cÃ¢u chuyá»‡n vÃ  mong muá»‘n cá»§a báº¡n.';
					}
				}

				function moveCurrentToEndAndAdvance() {
					if (!filtered.length) return;
					const [item] = filtered.splice(currentIndex, 1);
					if (item) filtered.push(item);
					render();
				}

				function scheduleAdvance() {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					advanceTimer = setTimeout(() => {
						advanceTimer = null;
						moveCurrentToEndAndAdvance();
					}, autoAdvanceDelayMs);
				}

				function removeCurrent() {
					if (!filtered.length) return;
					// Há»§y auto-advance náº¿u Ä‘ang Ä‘á»£i
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					const current = filtered[currentIndex];
					if (!current) return;
					// XÃ³a khá»i danh sÃ¡ch Ä‘Ã£ lá»c
					filtered.splice(currentIndex, 1);
					// XÃ³a khá»i ngÃ¢n hÃ ng dá»¯ liá»‡u gá»‘c trong phiÃªn hiá»‡n táº¡i
					const idxInData = data.findIndex(d => d.id === current.id);
					if (idxInData >= 0) data.splice(idxInData, 1);
					// Äáº£m báº£o index há»£p lá»‡ sau khi xÃ³a
					currentIndex = clampIndex(currentIndex);
					render();
				}
				function render() {
					if (!filtered.length) {
						qEl.textContent = 'KhÃ´ng cÃ³ dá»¯ liá»‡u';
						aEl.textContent = '';
						progressEl.textContent = 'CÃ¢u 0/0';
						setFlipped(false);
						revealStage = 0;
						answeredBtn.style.display = 'none';
						return;
					}
					const item = filtered[currentIndex];
					// Reset giai Ä‘oáº¡n hiá»ƒn thá»‹ vá» ban Ä‘áº§u
					revealStage = 0;
					updateFaces();
					progressEl.textContent = `CÃ¢u ${currentIndex + 1}/${filtered.length}`;
					// Badge & theme color per difficulty
					const diff = (item.difficulty || '').trim();
					badgeEl.textContent = diff || 'â€”';
					cardEl.classList.remove('theme-easy','theme-medium','theme-hard');
					if (diff === 'Dá»…') cardEl.classList.add('theme-easy');
					else if (diff === 'Vá»«a') cardEl.classList.add('theme-medium');
					else if (diff === 'KhÃ³') cardEl.classList.add('theme-hard');
					setFlipped(false);
					answeredBtn.style.display = 'none';
				}

				// Init difficulties
				const difficulties = uniq(data.map(d => d.difficulty).filter(Boolean)).sort();
				for (const c of difficulties) {
					const opt = document.createElement('option');
					opt.value = c;
					opt.textContent = c;
					difficultyFilterEl.appendChild(opt);
				}

				// Init topics (categories)
				const topics = uniq(data.map(d => d.category).filter(Boolean)).sort();
				for (const t of topics) {
					const opt = document.createElement('option');
					opt.value = t;
					opt.textContent = t;
					topicFilterEl.appendChild(opt);
				}

				function applyFilter() {
					const selDiff = difficultyFilterEl.value;
					const selTopic = topicFilterEl.value;
					filtered = data.filter(d => {
						const diffOk = selDiff === '__ALL__' ? true : d.difficulty === selDiff;
						const topicOk = selTopic === '__ALL__' ? true : (d.category === selTopic);
						return diffOk && topicOk;
					});
					currentIndex = 0;
					render();
				}

				// Wire events
				prevBtn.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					currentIndex = clampIndex(currentIndex - 1);
					render();
				});
				nextBtn.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					currentIndex = clampIndex(currentIndex + 1);
					render();
				});
				flipBtn.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					if (revealStage === 0) {
							revealStage = 1; // Hiá»‡n cÃ¢u há»i khi láº­t láº§n Ä‘áº§u
						updateFaces();
						setFlipped(true);
							answeredBtn.style.display = 'inline-flex';
						return;
					}
					if (revealStage === 1) {
							revealStage = 2; // Láº­t tiáº¿p Ä‘á»ƒ hiá»‡n Ä‘Ã¡p Ã¡n
						updateFaces();
						setFlipped(true);
						scheduleAdvance();
						return;
					}
					// Sau khi Ä‘Ã£ á»Ÿ giai Ä‘oáº¡n 2, hÃ nh vi láº­t quay láº¡i nhÆ° cÅ©
					const nowFlipped = !cardEl.classList.contains('flipped');
					setFlipped(nowFlipped);
					if (nowFlipped) scheduleAdvance(); else if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
				});
				shuffleBtn.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					filtered = fisherYatesShuffle(filtered.slice());
					currentIndex = 0;
					render();
				});
				answeredBtn.addEventListener('click', (ev) => {
					// KhÃ´ng kÃ­ch hoáº¡t láº­t tháº» khi báº¥m nÃºt bÃªn trong tháº»
					ev.stopPropagation();
					removeCurrent();
				});
				difficultyFilterEl.addEventListener('change', () => { if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; } applyFilter(); });
				topicFilterEl.addEventListener('change', () => { if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; } applyFilter(); });
				cardEl.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					if (revealStage === 0) {
						revealStage = 1;
						updateFaces();
						setFlipped(true);
						answeredBtn.style.display = 'inline-flex';
						return;
					}
					if (revealStage === 1) {
						revealStage = 2;
						updateFaces();
						setFlipped(true);
						scheduleAdvance();
						return;
					}
					const nowFlipped = !cardEl.classList.contains('flipped');
					setFlipped(nowFlipped);
					if (nowFlipped) scheduleAdvance(); else if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
				});
				cardEl.addEventListener('keydown', (ev) => {
					if (ev.key === 'Enter' || ev.key === ' ') {
						ev.preventDefault();
						if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
						if (revealStage === 0) {
							revealStage = 1;
							updateFaces();
							setFlipped(true);
							answeredBtn.style.display = 'inline-flex';
							return;
						}
						if (revealStage === 1) {
							revealStage = 2;
							updateFaces();
							setFlipped(true);
							scheduleAdvance();
							return;
						}
						const nowFlipped = !cardEl.classList.contains('flipped');
						setFlipped(nowFlipped);
						if (nowFlipped) scheduleAdvance(); else if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					}
				});

				// Keyboard shortcuts
				window.addEventListener('keydown', (ev) => {
					if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.tagName === 'TEXTAREA')) return;
					if (ev.key === 'ArrowLeft') { prevBtn.click(); }
					else if (ev.key === 'ArrowRight') { nextBtn.click(); }
					else if (ev.key === ' ') { ev.preventDefault(); flipBtn.click(); }
					else if (ev.key.toLowerCase() === 's') { shuffleBtn.click(); }
					else if (ev.key.toLowerCase() === 'x') { answeredBtn.click(); }
				});

				// First render
				applyFilter();
			})();
		</script>
	</body>
</html>

