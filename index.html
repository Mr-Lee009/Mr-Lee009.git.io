<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Deep Connect ‚Äî Quiz Flip</title>
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<div class="app">
			<header class="app-header">
				<h1>Deep Connect</h1>
				<div class="controls">
					<label class="sr-only" for="difficultyFilter">Difficulty</label>
					<select id="difficultyFilter" class="control">
						<option value="__ALL__">All difficulties</option>
					</select>

					<label class="sr-only" for="topicFilter">Topic</label>
					<select id="topicFilter" class="control">
						<option value="__ALL__">All topics</option>
					</select>

					<div class="spacer"></div>

					<button id="prevBtn" class="control">‚óÄ Prev</button>
					<button id="flipBtn" class="control primary">Flip</button>
					<button id="nextBtn" class="control">Next ‚ñ∂</button>
					<button id="shuffleBtn" class="control">üîÄ Shuffle</button>
				</div>
				<div id="progress" class="progress">Card 0/0</div>
			</header>

			<main class="stage">
				<div id="card" class="card" aria-label="Question card" role="button" tabindex="0">
					<div class="badge difficulty-badge" id="difficultyBadge">Difficulty</div>
					<div class="face front" id="cardQuestion">Question</div>
					<div class="face back" id="cardAnswer">Answer</div>
					<button id="answeredBtn" class="card-action" title="Mark answered and remove from bank">‚úî Answered</button>
				</div>
			</main>

			<footer class="app-footer">
				<div class="hints">
					<span>Shortcuts: Space=Flip ‚Ä¢ ‚Üê/‚Üí=Prev/Next ‚Ä¢ S=Shuffle</span>
				</div>
			</footer>
		</div>

		<!-- Data source -->
		<script src="data.js"></script>
		<!-- Inline logic for a simple static build -->
		<script>
			(function () {
				const data = (window.DeepConnectData || []).slice();
				// Auto-advance after flipping to the back
				const autoAdvanceDelayMs = 1800;
				let advanceTimer = null;

				// Audio
				let audioCtx = null;
				function ensureAudio() {
					if (!audioCtx) {
						audioCtx = new (window.AudioContext || window.webkitAudioContext)();
					}
					if (audioCtx.state === 'suspended') {
						audioCtx.resume();
					}
				}
				function playFlipOpen() {
					ensureAudio();
					const ctx = audioCtx;
					const osc = ctx.createOscillator();
					const gain = ctx.createGain();
					osc.type = 'triangle';
					osc.frequency.setValueAtTime(600, ctx.currentTime);
					gain.gain.setValueAtTime(0, ctx.currentTime);
					gain.gain.linearRampToValueAtTime(0.18, ctx.currentTime + 0.02);
					gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.22);
					osc.connect(gain).connect(ctx.destination);
					osc.start(ctx.currentTime);
					osc.stop(ctx.currentTime + 0.24);
				}

				function playFlipClose() {
					ensureAudio();
					const ctx = audioCtx;
					const osc = ctx.createOscillator();
					const gain = ctx.createGain();
					osc.type = 'sine';
					osc.frequency.setValueAtTime(240, ctx.currentTime);
					osc.frequency.exponentialRampToValueAtTime(140, ctx.currentTime + 0.15);
					gain.gain.setValueAtTime(0, ctx.currentTime);
					gain.gain.linearRampToValueAtTime(0.16, ctx.currentTime + 0.02);
					gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.18);
					osc.connect(gain).connect(ctx.destination);
					osc.start(ctx.currentTime);
					osc.stop(ctx.currentTime + 0.2);
				}

				// State
				let filtered = data.slice();
				let currentIndex = 0;

				// Elements
				const difficultyFilterEl = document.getElementById('difficultyFilter');
				const topicFilterEl = document.getElementById('topicFilter');
				const prevBtn = document.getElementById('prevBtn');
				const nextBtn = document.getElementById('nextBtn');
				const flipBtn = document.getElementById('flipBtn');
				const shuffleBtn = document.getElementById('shuffleBtn');
				const answeredBtn = document.getElementById('answeredBtn');
				const cardEl = document.getElementById('card');
				const qEl = document.getElementById('cardQuestion');
				const aEl = document.getElementById('cardAnswer');
				const progressEl = document.getElementById('progress');
				const badgeEl = document.getElementById('difficultyBadge');

				// Helpers
				function uniq(xs) {
					return Array.from(new Set(xs));
				}
				function fisherYatesShuffle(arr) {
					for (let i = arr.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[arr[i], arr[j]] = [arr[j], arr[i]];
					}
					return arr;
				}
				function clampIndex(i) {
					if (!filtered.length) return 0;
					while (i < 0) i += filtered.length;
					while (i >= filtered.length) i -= filtered.length;
					return i;
				}
				function setFlipped(flipped) {
					const want = !!flipped;
					const was = cardEl.classList.contains('flipped');
					if (was === want) return;
					cardEl.classList.toggle('flipped', want);
					if (want) playFlipOpen(); else playFlipClose();
				}

				function updateFaces() {
					if (!filtered.length) return;
					const item = filtered[currentIndex];
					// Front shows the card number
					qEl.textContent = `Card ${currentIndex + 1}`;
					// Back always shows the question (two states only: flipped / not flipped)
					aEl.textContent = item.question || '';
				}

				function moveCurrentToEndAndAdvance() {
					if (!filtered.length) return;
					const [item] = filtered.splice(currentIndex, 1);
					if (item) filtered.push(item);
					render();
				}

				function scheduleAdvance() {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					advanceTimer = setTimeout(() => {
						advanceTimer = null;
						moveCurrentToEndAndAdvance();
					}, autoAdvanceDelayMs);
				}

				function removeCurrent() {
					if (!filtered.length) return;
					// H·ªßy auto-advance n·∫øu ƒëang ƒë·ª£i
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					const current = filtered[currentIndex];
					if (!current) return;
					// X√≥a kh·ªèi danh s√°ch ƒë√£ l·ªçc
					filtered.splice(currentIndex, 1);
					// X√≥a kh·ªèi ng√¢n h√†ng d·ªØ li·ªáu g·ªëc trong phi√™n hi·ªán t·∫°i
					const idxInData = data.findIndex(d => d.id === current.id);
					if (idxInData >= 0) data.splice(idxInData, 1);
					// ƒê·∫£m b·∫£o index h·ª£p l·ªá sau khi x√≥a
					currentIndex = clampIndex(currentIndex);
					render();
				}
				function render() {
					if (!filtered.length) {
						qEl.textContent = 'No data';
						aEl.textContent = '';
						progressEl.textContent = 'Card 0/0';
						setFlipped(false);
						revealStage = 0;
						answeredBtn.style.display = 'none';
						return;
					}
					const item = filtered[currentIndex];
					updateFaces();
					progressEl.textContent = `Card ${currentIndex + 1}/${filtered.length}`;
					// Badge & theme color per difficulty
					const diff = (item.difficulty || '').trim();
					badgeEl.textContent = diff || '‚Äî';
					cardEl.classList.remove('theme-easy','theme-medium','theme-hard');
					if (diff === 'Easy') cardEl.classList.add('theme-easy');
					else if (diff === 'Medium') cardEl.classList.add('theme-medium');
					else if (diff === 'Hard') cardEl.classList.add('theme-hard');
					setFlipped(false);
					answeredBtn.style.display = 'none';
				}

				// Init difficulties (normalize whitespace)
				const difficulties = uniq(data.map(d => (d.difficulty || '').trim()).filter(Boolean)).sort();
				for (const c of difficulties) {
					const opt = document.createElement('option');
					opt.value = c;
					opt.textContent = c;
					difficultyFilterEl.appendChild(opt);
				}

				// Init topics (categories)
				// Normalize: trim, collapse whitespace, sort with Vietnamese collation
				function normalizeCategory(s) {
					// Trim, replace underscores with spaces, collapse multiple spaces
					return (s || '').toString().trim().replace(/_/g, ' ').replace(/\s+/g, ' ');
				}
				const rawTopics = data.map(d => normalizeCategory(d.category)).filter(Boolean);
				const topics = uniq(rawTopics).sort((a, b) => a.localeCompare(b, 'vi'));
				// Map known category keys (now English) to nicer display labels
				const categoryDisplayMap = {
					'Love': 'Love',
					'Food': 'Food',
					'Travel': 'Travel',
					'Family': 'Family',
					'Friends': 'Friends',
					'Valentine': 'Valentine',
					'Tet Viet': 'Tet Viet',
					'Tet_Viet': 'Tet Viet'
				};
				for (const t of topics) {
					const opt = document.createElement('option');
					// keep option value as the original (Vietnamese) category so filtering still works
					opt.value = t;
					opt.textContent = categoryDisplayMap[t] || t;
					topicFilterEl.appendChild(opt);
				}
				// Debug: if you still don't see a category, open console to inspect normalized list
				console.debug('topics initialized (normalized):', topics);

				function applyFilter() {
					const selDiff = difficultyFilterEl.value;
					const selTopic = topicFilterEl.value;
					filtered = data.filter(d => {
						const diff = (d.difficulty || '').trim();
						const cat = normalizeCategory(d.category);
						const diffOk = selDiff === '__ALL__' ? true : diff === selDiff;
						const topicOk = selTopic === '__ALL__' ? true : (cat === selTopic);
						return diffOk && topicOk;
					});
					currentIndex = 0;
					render();
				}

				// Wire events
				prevBtn.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					currentIndex = clampIndex(currentIndex - 1);
					render();
				});
				nextBtn.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					currentIndex = clampIndex(currentIndex + 1);
					render();
				});
				flipBtn.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					const nowFlipped = !cardEl.classList.contains('flipped');
					setFlipped(nowFlipped);
					if (nowFlipped) answeredBtn.style.display = 'inline-flex'; else answeredBtn.style.display = 'none';
				});
				shuffleBtn.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					filtered = fisherYatesShuffle(filtered.slice());
					currentIndex = 0;
					render();
				});
				answeredBtn.addEventListener('click', (ev) => {
					// Kh√¥ng k√≠ch ho·∫°t l·∫≠t th·∫ª khi b·∫•m n√∫t b√™n trong th·∫ª
					ev.stopPropagation();
					removeCurrent();
				});
				difficultyFilterEl.addEventListener('change', () => { if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; } applyFilter(); });
				topicFilterEl.addEventListener('change', () => { if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; } applyFilter(); });
				cardEl.addEventListener('click', () => {
					if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
					const nowFlipped = !cardEl.classList.contains('flipped');
					setFlipped(nowFlipped);
					if (nowFlipped) answeredBtn.style.display = 'inline-flex'; else answeredBtn.style.display = 'none';
				});
				cardEl.addEventListener('keydown', (ev) => {
					if (ev.key === 'Enter' || ev.key === ' ') {
						ev.preventDefault();
						if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
						const nowFlipped = !cardEl.classList.contains('flipped');
						setFlipped(nowFlipped);
						if (nowFlipped) answeredBtn.style.display = 'inline-flex'; else answeredBtn.style.display = 'none';
					}
				});

				// Keyboard shortcuts
				window.addEventListener('keydown', (ev) => {
					if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.tagName === 'TEXTAREA')) return;
					if (ev.key === 'ArrowLeft') { prevBtn.click(); }
					else if (ev.key === 'ArrowRight') { nextBtn.click(); }
					else if (ev.key === ' ') { ev.preventDefault(); flipBtn.click(); }
					else if (ev.key.toLowerCase() === 's') { shuffleBtn.click(); }
					else if (ev.key.toLowerCase() === 'x') { answeredBtn.click(); }
				});

				// First render
				applyFilter();
			})();
		</script>
	</body>
</html>

